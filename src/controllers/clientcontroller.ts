import { Request, Response } from 'express';
import mongoose, { Types } from 'mongoose';
import Employee from "../models/employee";
import Department from "../models/department";
import Role from '../models/role';
import { IEmployee, User } from '../dtos/userdto';
import { EmployeeUpdateFields } from '../dtos/employeedto';
import { ClientUpdateFields } from '../dtos/userdto';
import { Client } from '../models/client';
import Ticket from '../models/ticket';
import { Project } from '../models/projects';
import Invoice from '../models/invoice';

export interface AuthRequest extends Request {
  user?: User;
}

export class ClientController {
    async updateClient(req: Request, res: Response): Promise<Response> {
        try {
          const updateData: ClientUpdateFields = req.body;
          const { id } = req.body; 
    
          // Validate if id is provided
          if (!id || !Types.ObjectId.isValid(id)) {
            return res.status(400).json({
              message: 'Valid client ID is required'
            });
          }
          
          // Check if client exists
          const existingClient = await Client.findById(id);
          
          if (!existingClient) {
            return res.status(404).json({
              message: `Client with ID ${id} not found`
            });
          }
          
          const updateFields: ClientUpdateFields = {};
          
          // Map all fields from the model
          const fields = [
            'companyName',
            'contactPerson',
            'phone',
            'address',
            'description'
          ];
      
          fields.forEach(field => {
            if (updateData[field] !== undefined) {
              updateFields[field] = updateData[field];
            }
          });
          
          // Update the client
          const updatedClient = await Client.findByIdAndUpdate(
            id,
            { $set: updateFields },
            {
              new: true,
              runValidators: true
            }
          );
          
          if (!updatedClient) {
            return res.status(500).json({
              message: 'Client update failed'
            });
          }
          
          return res.status(200).json({
            message: 'Client updated successfully',
            data: updatedClient
          });
          
        } catch (error) {
          return res.status(500).json({
            message: "Error updating client",
            error: error instanceof Error ? error.message : "Unknown error",
          });
        }
      }

    async createTicket(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { title, description, priority } = req.body;
    
        // Validate required fields
        if (!title || !description) {
          return res.status(400).json({
            success: false,
            message: "Title and description are required"
          });
        }
    
        // Validate priority if provided
        if (priority && !['Low', 'Medium', 'High'].includes(priority)) {
          return res.status(400).json({
            success: false,
            message: "Priority must be 'Low', 'Medium', or 'High'"
          });
        }
    
        // Create the ticket
        const ticket = new Ticket({
          client_id: clientId,
          title,
          description,
          priority: priority || 'Medium',
          status: 'Pending'
          // ticketCode will be auto-generated by the pre-save middleware
        });
    
        const savedTicket = await ticket.save();
    
        return res.status(201).json({
          success: true,
          message: "Ticket created successfully",
          ticket: {
            id: savedTicket._id,
            ticketCode: savedTicket.ticketCode,
            title: savedTicket.title,
            description: savedTicket.description,
            priority: savedTicket.priority,
            status: savedTicket.status,
            createdAt: savedTicket.createdAt
          }
        });
    
      } catch (error) {
        console.error('Error creating ticket:', error);
    
        return res.status(500).json({
          success: false,
          message: "Error creating ticket",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    
    async getClientTickets(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { status, priority, sort = 'createdAt', order = 'desc' } = req.query;
    
        // Build query
        const query: any = { client_id: clientId };
    
        // Filter by status if provided
        if (status) {
          if (!['Pending', 'In Progress', 'Resolved', 'Closed'].includes(status as string)) {
            return res.status(400).json({
              success: false,
              message: "Invalid status value"
            });
          }
          query.status = status;
        }
    
        // Filter by priority if provided
        if (priority) {
          if (!['Low', 'Medium', 'High'].includes(priority as string)) {
            return res.status(400).json({
              success: false,
              message: "Invalid priority value"
            });
          }
          query.priority = priority;
        }
    
        // Determine sort order
        const sortOptions: any = {};
        sortOptions[sort as string] = order === 'asc' ? 1 : -1;
    
        // Find tickets
        const tickets = await Ticket.find(query)
          .sort(sortOptions)
          .populate('assignedTo', 'firstName lastName employee_id')
          .lean();
    
        // Prepare summary statistics
        const summary = {
          total: tickets.length,
          pending: tickets.filter(ticket => ticket.status === 'Pending').length,
          inProgress: tickets.filter(ticket => ticket.status === 'In Progress').length,
          resolved: tickets.filter(ticket => ticket.status === 'Resolved').length,
          closed: tickets.filter(ticket => ticket.status === 'Closed').length,
          highPriority: tickets.filter(ticket => ticket.priority === 'High').length
        };
    
        // Map tickets to ensure ticketCode is included in the response
        const formattedTickets = tickets.map(ticket => ({
          id: ticket._id,
          ticketCode: ticket.ticketCode,
          title: ticket.title,
          description: ticket.description,
          priority: ticket.priority,
          status: ticket.status,
          createdAt: ticket.createdAt,
          assignedTo: ticket.assignedTo,
          comments: ticket.comments
        }));
    
        return res.status(200).json({
          success: true,
          message: "Tickets retrieved successfully",
          summary,
          tickets: formattedTickets
        });
    
      } catch (error) {
        console.error('Error retrieving tickets:', error);
    
        return res.status(500).json({
          success: false,
          message: "Error retrieving tickets",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }

    async deleteTicket(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { id, ticketCode } = req.body;
        
        // Validate we have either id or ticketCode
        if (!id && !ticketCode) {
          return res.status(400).json({
            success: false,
            message: "Either ticket ID or ticketCode is required"
          });
        }
        
        // Find ticket
        let ticket;
        if (id && Types.ObjectId.isValid(id)) {
          ticket = await Ticket.findOne({ _id: id, client_id: clientId });
        } else if (ticketCode) {
          ticket = await Ticket.findOne({ ticketCode, client_id: clientId });
        }
        
        if (!ticket) {
          return res.status(404).json({
            success: false,
            message: "Ticket not found or not owned by you"
          });
        }
        
        // Check if ticket is in a status that allows deletion
        if (ticket.status === 'In Progress' || ticket.status === 'Resolved') {
          return res.status(400).json({
            success: false,
            message: `Cannot delete ticket in ${ticket.status} status. Only tickets in 'Pending' or 'Closed' status can be deleted.`
          });
        }
        
        // Delete the ticket
        await Ticket.findByIdAndDelete(ticket._id);
        
        return res.status(200).json({
          success: true,
          message: `Ticket ${ticketCode || id} deleted successfully`
        });
        
      } catch (error) {
        console.error('Error deleting ticket:', error);
        
        return res.status(500).json({
          success: false,
          message: "Error deleting ticket",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }

    async getClientProjects(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { status } = req.query;
        
        // Build query - find projects assigned to this client
        const query: any = { client: new Types.ObjectId(clientId) };
        
        // Add status filter if provided
        if (status) {
          if (!['Not Started', 'In Progress', 'Completed', 'On Hold'].includes(status as string)) {
            return res.status(400).json({
              success: false,
              message: "Invalid status value. Must be 'Not Started', 'In Progress', 'Completed', or 'On Hold'"
            });
          }
          query.status = status;
        }
    
        // Find projects
        const projects = await Project.find(query)
          .sort({ startDate: 1 }) // Sort by start date (ascending)
          .populate('teamLeaders', 'firstName lastName employee_id')
          .populate('teamMembers', 'firstName lastName employee_id')
          .populate('managers', 'firstName lastName employee_id')
          .populate('created_by', 'firstName lastName employee_id')
          .lean();
    
        // Calculate summary statistics
        const total = projects.length;
        const completed = projects.filter(project => project.status === 'Completed').length;
        const inProgress = projects.filter(project => project.status === 'In Progress').length;
        const notStarted = projects.filter(project => project.status === 'Not Started').length;
        const onHold = projects.filter(project => project.status === 'On Hold').length;
        const highPriority = projects.filter(project => project.priority === 'High').length;
        
        // Calculate completion percentage
        const completionPercentage = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        // Calculate overall progress including in-progress projects (weighted calculation)
        let overallProgress = 0;
        if (total > 0) {
          // Assign weights: Completed = 100%, In Progress = 50%, Not Started = 0%, On Hold = counted but no progress
          overallProgress = Math.round(
            ((completed * 100) + (inProgress * 50)) / total
          );
        }
        
        const summary = {
          total,
          completed,
          notStarted,
          inProgress,
          onHold,
          highPriority,
          completionPercentage,
          overallProgress
        };
    
        // Format projects for response
        const formattedProjects = projects.map(project => {
          // Add type assertion for teamLeaders
          const teamLeadersArray = project.teamLeaders as unknown as Array<{
            firstName: string;
            lastName: string;
            employee_id: string;
          }>;
          
          const teamLeader = teamLeadersArray && teamLeadersArray.length > 0 
            ? `${teamLeadersArray[0].firstName} ${teamLeadersArray[0].lastName}` 
            : 'Not assigned';
          
          const daysToStart = project.status === 'Not Started' ? 
            Math.ceil((new Date(project.startDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)) : 0;
          
          const daysRemaining = project.status !== 'Completed' ? 
            Math.ceil((new Date(project.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)) : 0;
          
          // Calculate individual project progress percentage
          let progressPercentage = 0;
          switch(project.status) {
            case 'Completed':
              progressPercentage = 100;
              break;
            case 'In Progress':
              // Calculate based on timeline - if halfway through timeline, assume 50% complete
              const totalDuration = new Date(project.endDate).getTime() - new Date(project.startDate).getTime();
              const elapsedDuration = new Date().getTime() - new Date(project.startDate).getTime();
              
              if (totalDuration > 0) {
                progressPercentage = Math.min(
                  Math.round((elapsedDuration / totalDuration) * 100),
                  99 // Cap at 99% for in-progress projects
                );
                // Minimum 10% for just started projects
                progressPercentage = Math.max(progressPercentage, 10);
              }
              break;
            case 'Not Started':
              progressPercentage = 0;
              break;
            case 'On Hold':
              // For on hold, show the progress at the time it was paused (estimate)
              const totalDays = (new Date(project.endDate).getTime() - new Date(project.startDate).getTime()) / (1000 * 60 * 60 * 24);
              const elapsedDays = (new Date().getTime() - new Date(project.startDate).getTime()) / (1000 * 60 * 60 * 24);
              
              if (totalDays > 0) {
                progressPercentage = Math.min(
                  Math.round((elapsedDays / totalDays) * 100 * 0.5), // Only count 50% of elapsed time for on-hold
                  75 // Cap at 75% for on-hold projects
                );
              }
              break;
          }
          
          return {
            id: project._id,
            projectName: project.projectName,
            description: project.projectDescription,
            startDate: project.startDate,
            endDate: project.endDate,
            status: project.status,
            priority: project.priority,
            teamSize: (project.teamMembers?.length || 0) + (project.teamLeaders?.length || 0),
            leadContact: teamLeader,
            progressPercentage,
            timeframe: {
              daysToStart: daysToStart > 0 ? daysToStart : 0,
              daysRemaining: daysRemaining > 0 ? daysRemaining : 0,
              isOverdue: project.status !== 'Completed' && new Date(project.endDate) < new Date()
            },
            tags: project.tags || [],
            value: project.projectValue
          };
        });
    
        return res.status(200).json({
          success: true,
          message: "Projects retrieved successfully",
          summary,
          projects: formattedProjects
        });
    
      } catch (error) {
        console.error('Error retrieving projects:', error);
    
        return res.status(500).json({
          success: false,
          message: "Error retrieving projects",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }

    async getClientInvoices(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { status } = req.query;
        
        // Build query - find invoices for this client
        const query: any = { client_id: new Types.ObjectId(clientId) };
        
        // Add status filter if provided
        if (status) {
          if (!['Pending', 'Paid', 'Overdue'].includes(status as string)) {
            return res.status(400).json({
              success: false,
              message: "Invalid status. Must be 'Pending', 'Paid', or 'Overdue'"
            });
          }
          query.status = status;
        }
        
        const invoices = await Invoice.find(query)
          .sort({ invoiceDate: -1 })
          .populate('project_id', 'projectName');
        
        // Calculate statistics
        const totalAmount = invoices.reduce((sum, invoice) => sum + invoice.amount, 0);
        const pendingAmount = invoices
          .filter(invoice => invoice.status === 'Pending')
          .reduce((sum, invoice) => sum + invoice.amount, 0);
        const overdueAmount = invoices
          .filter(invoice => invoice.status === 'Overdue')
          .reduce((sum, invoice) => sum + invoice.amount, 0);
        
        const summary = {
          total: invoices.length,
          pending: invoices.filter(invoice => invoice.status === 'Pending').length,
          paid: invoices.filter(invoice => invoice.status === 'Paid').length,
          overdue: invoices.filter(invoice => invoice.status === 'Overdue').length,
          totalAmount,
          pendingAmount,
          overdueAmount
        };
        
        return res.status(200).json({
          success: true,
          message: "Invoices retrieved successfully",
          summary,
          data: invoices
        });
        
      } catch (error) {
        console.error('Error retrieving client invoices:', error);
        return res.status(500).json({
          success: false,
          message: "Error retrieving invoices",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    
    async getClientInvoiceDetails(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { invoice_id } = req.body;
        
        if (!invoice_id) {
          return res.status(400).json({
            success: false,
            message: "Invoice ID is required"
          });
        }
        
        const invoice = await Invoice.findOne({
          invoice_id,
          client_id: clientId
        })
        .populate('project_id', 'projectName');
        
        if (!invoice) {
          return res.status(404).json({
            success: false,
            message: "Invoice not found or not accessible by this client"
          });
        }
        
        return res.status(200).json({
          success: true,
          message: "Invoice retrieved successfully",
          data: invoice
        });
        
      } catch (error) {
        console.error('Error retrieving invoice details:', error);
        return res.status(500).json({
          success: false,
          message: "Error retrieving invoice details",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
}