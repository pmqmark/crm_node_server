import { Request, Response } from 'express';
import mongoose, { Types } from 'mongoose';
import Employee from "../models/employee";
import Department from "../models/department";
import Role from '../models/role';
import { IEmployee, User } from '../dtos/userdto';
import { EmployeeUpdateFields } from '../dtos/employeedto';
import { ClientUpdateFields } from '../dtos/userdto';
import { Client } from '../models/client';
import Ticket from '../models/ticket';

export interface AuthRequest extends Request {
  user?: User;
}

export class ClientController {
    async updateClient(req: Request, res: Response): Promise<Response> {
        try {
          const updateData: ClientUpdateFields = req.body;
          const { id } = req.body; 
    
          // Validate if id is provided
          if (!id || !Types.ObjectId.isValid(id)) {
            return res.status(400).json({
              message: 'Valid client ID is required'
            });
          }
          
          // Check if client exists
          const existingClient = await Client.findById(id);
          
          if (!existingClient) {
            return res.status(404).json({
              message: `Client with ID ${id} not found`
            });
          }
          
          const updateFields: ClientUpdateFields = {};
          
          // Map all fields from the model
          const fields = [
            'companyName',
            'contactPerson',
            'phone',
            'address',
            'description'
          ];
      
          fields.forEach(field => {
            if (updateData[field] !== undefined) {
              updateFields[field] = updateData[field];
            }
          });
          
          // Update the client
          const updatedClient = await Client.findByIdAndUpdate(
            id,
            { $set: updateFields },
            {
              new: true,
              runValidators: true
            }
          );
          
          if (!updatedClient) {
            return res.status(500).json({
              message: 'Client update failed'
            });
          }
          
          return res.status(200).json({
            message: 'Client updated successfully',
            data: updatedClient
          });
          
        } catch (error) {
          return res.status(500).json({
            message: "Error updating client",
            error: error instanceof Error ? error.message : "Unknown error",
          });
        }
      }

    async createTicket(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { title, description, priority } = req.body;
    
        // Validate required fields
        if (!title || !description) {
          return res.status(400).json({
            success: false,
            message: "Title and description are required"
          });
        }
    
        // Validate priority if provided
        if (priority && !['Low', 'Medium', 'High'].includes(priority)) {
          return res.status(400).json({
            success: false,
            message: "Priority must be 'Low', 'Medium', or 'High'"
          });
        }
    
        // Create the ticket
        const ticket = new Ticket({
          client_id: clientId,
          title,
          description,
          priority: priority || 'Medium',
          status: 'Pending'
          // ticketCode will be auto-generated by the pre-save middleware
        });
    
        const savedTicket = await ticket.save();
    
        return res.status(201).json({
          success: true,
          message: "Ticket created successfully",
          ticket: {
            id: savedTicket._id,
            ticketCode: savedTicket.ticketCode,
            title: savedTicket.title,
            description: savedTicket.description,
            priority: savedTicket.priority,
            status: savedTicket.status,
            createdAt: savedTicket.createdAt
          }
        });
    
      } catch (error) {
        console.error('Error creating ticket:', error);
    
        return res.status(500).json({
          success: false,
          message: "Error creating ticket",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    
    async getClientTickets(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { status, priority, sort = 'createdAt', order = 'desc' } = req.query;
    
        // Build query
        const query: any = { client_id: clientId };
    
        // Filter by status if provided
        if (status) {
          if (!['Pending', 'In Progress', 'Resolved', 'Closed'].includes(status as string)) {
            return res.status(400).json({
              success: false,
              message: "Invalid status value"
            });
          }
          query.status = status;
        }
    
        // Filter by priority if provided
        if (priority) {
          if (!['Low', 'Medium', 'High'].includes(priority as string)) {
            return res.status(400).json({
              success: false,
              message: "Invalid priority value"
            });
          }
          query.priority = priority;
        }
    
        // Determine sort order
        const sortOptions: any = {};
        sortOptions[sort as string] = order === 'asc' ? 1 : -1;
    
        // Find tickets
        const tickets = await Ticket.find(query)
          .sort(sortOptions)
          .populate('assignedTo', 'firstName lastName employee_id')
          .lean();
    
        // Prepare summary statistics
        const summary = {
          total: tickets.length,
          pending: tickets.filter(ticket => ticket.status === 'Pending').length,
          inProgress: tickets.filter(ticket => ticket.status === 'In Progress').length,
          resolved: tickets.filter(ticket => ticket.status === 'Resolved').length,
          closed: tickets.filter(ticket => ticket.status === 'Closed').length,
          highPriority: tickets.filter(ticket => ticket.priority === 'High').length
        };
    
        // Map tickets to ensure ticketCode is included in the response
        const formattedTickets = tickets.map(ticket => ({
          id: ticket._id,
          ticketCode: ticket.ticketCode,
          title: ticket.title,
          description: ticket.description,
          priority: ticket.priority,
          status: ticket.status,
          createdAt: ticket.createdAt,
          assignedTo: ticket.assignedTo,
          comments: ticket.comments
        }));
    
        return res.status(200).json({
          success: true,
          message: "Tickets retrieved successfully",
          summary,
          tickets: formattedTickets
        });
    
      } catch (error) {
        console.error('Error retrieving tickets:', error);
    
        return res.status(500).json({
          success: false,
          message: "Error retrieving tickets",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }

    async deleteTicket(req: AuthRequest, res: Response): Promise<Response> {
      try {
        if (!req.user || !req.user.id) {
          return res.status(401).json({
            success: false,
            message: "User not authenticated"
          });
        }
    
        const clientId = req.user.id;
        const { id, ticketCode } = req.body;
        
        // Validate we have either id or ticketCode
        if (!id && !ticketCode) {
          return res.status(400).json({
            success: false,
            message: "Either ticket ID or ticketCode is required"
          });
        }
        
        // Find ticket
        let ticket;
        if (id && Types.ObjectId.isValid(id)) {
          ticket = await Ticket.findOne({ _id: id, client_id: clientId });
        } else if (ticketCode) {
          ticket = await Ticket.findOne({ ticketCode, client_id: clientId });
        }
        
        if (!ticket) {
          return res.status(404).json({
            success: false,
            message: "Ticket not found or not owned by you"
          });
        }
        
        // Check if ticket is in a status that allows deletion
        if (ticket.status === 'In Progress' || ticket.status === 'Resolved') {
          return res.status(400).json({
            success: false,
            message: `Cannot delete ticket in ${ticket.status} status. Only tickets in 'Pending' or 'Closed' status can be deleted.`
          });
        }
        
        // Delete the ticket
        await Ticket.findByIdAndDelete(ticket._id);
        
        return res.status(200).json({
          success: true,
          message: `Ticket ${ticketCode || id} deleted successfully`
        });
        
      } catch (error) {
        console.error('Error deleting ticket:', error);
        
        return res.status(500).json({
          success: false,
          message: "Error deleting ticket",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
}